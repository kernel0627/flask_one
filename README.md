# **报告**

## **一.读题**

### 很幸运的被认为没有基础，但是确实看不懂docker it Yourself . 因此只能够来看这个易的题目。这个还是很明确的。看了看具体的内容感觉就是一个request的get的方法的项目还是比较好做的（但是事实上好像不是）。

## **二.设计思路**

### 这个整个项目首先我肯定是用flask，主要是很简单，fastapi有想过，但是还是不是很熟悉，但是我估计把我的代码直接改几个异步的问题就可以直接搬过去了。（估计会更好，但是得重构的话，这种活我一般都是给ai来做，这里就算了，主要是不熟的问题）。

### **整体的流程**

#### 1.接受url请求

#### 2.路径解析：

- 得到包名(vue) 、版本号(3.0.0 or ~3.0.0) 和路径(dist/vue.esm-broswer.js)

#### 3.处理版本：

- 检测版本号是否为一个范围表达式，而非具体版本
- get到包的所有的版本号信息
- 用nodesemver的max_satifying方法，得到最大的满足要求的版本号

#### 4. 获取包信息：

- 用具体的版本号get元数据，然后获得里面的地址，并进行缓存(@cache.memorize())

#### 5.下载解压包：

- 根据tarball的地址(要函数从元数据里面得到)，下载压缩包文件，包会被缓存。
- tarfile的open来得到解压包的数据

#### 6.文件响应

- 根据url的文件路径来从解压的后的数据提取文件
- 根据路径来确定，把文件返回，包的全部内容会被缓存

## **三、遇到的问题**

#### 1.这个io二进制和tarfile的部分。主要之前做的都是crud，第一次做这种项目，也是第一次接触tarball。然后网上搜索才知道有这个tarfile的库，嗯这个的文档还是比较好懂的。其实我想过说要不要那个缓存的部分干脆就不做了，直接用tar.add来做的话那样不也可以有一点缓存类似的功能吗，后面的话还是觉得不太行内存肯定会爆，就决定算了。

#### 2.然后是这个现在还在不断在我的这个终端里面警告的东西，说我的dist不是一个字典说是个元组，我这个真的是测试了很多遍，从来没有在打印的时候是个字典但是就是会警告。然后呢，是这个ico的问题，嗯我估计我可能下一版就改一下，现在说是npm估计会自己要ico但是我没有准备，后面加一下就行。

#### 3.然后是这个semver这个啥特殊版本号处理的时候，这个是后面下来加上去的嘛，其实这里的话，这个我是直接ai问的有什么好的推荐的库，然后我估计是没有注意备注py但是似乎好像也不是，因为我备注之后他又给我推荐pip的工具，那肯定不好啊，那样的话，估计还得要把^~这种的换成><这种，又是大量的ifelse，而且多半得乱，然后呢经过我不懈的努力，我终于找到了nodesemver，这个就好用多了。几乎就是node的js的原本的库一样，完美满足需求啊。

#### 4.关于缓存的库选择也有着问题，要用redis还是说用cachetools(这个时候甚至不知道有flask_caching)然后后面具体问了ai之后，我发现有这么个专门给flask的库就用了。然后呢因为用redis的话，我是找到了有redis-on-windows的github开源项目了但是感觉还是不太好然后我的电脑现在是用不了wsl虚拟机连不上ssh，就得用云，用云的话就比较麻烦。我想着就先做个mvp就得了，就想着flask_caching里面的一个是simple和一个filesystem两种缓存。用simple是内存的，这个多半得爆，所以算了，然后就选择了现在这个缓存到硬盘上的设计。

## **四、项目优劣处**

#### 1.优点

- 功能健全，可以缓存可以处理复杂的版本号。
- 逻辑及其简单，功能全部模块化。

#### 2.缺点

- 下载的速度还是太慢了，性能要提升，有能力的话换一下fastapi估计会好很多
- 缓存还是不得行，得换成redis之类的高端东西
- 这个由于我真的不是很熟悉tryerror，所以我的基本都是ifelse，这个有点问题。可能会改如果有时间的话。
- 还有就是这个打包的功能，完全没用过目前还在看文档（但由于出去玩了，没做完:）

##  **五、做项目的整个过程**

#### 首先是这个基础部分的功能。这个很好做，既然是三种不同的返回，我就直接ifelse就分类得了，然后原本是打算说直接三个大分类就得了，后面发现应该要先处理一下url再来分别处理会比较好一点。

#### 然后呢，这个我最开始确实没有学习过关于tar的内容，看了文档，发现好像这个只要用一个open就完了，也是很神奇了。然后就嗯，直接按照要求分发到里面去，一开始是先做目录的，这个我最开始看了眼需求文档里面的说是直接一个ul>li就得了，然后我最开始就是直接做的字典返回打印，然后做完了另外两个后我才回头把这个换成了ul>li这个还是很简单的，但是主要我平常写前端都是用ai的，所以我这里后面决定加了一个branch专门改了这个部分换成了一个aigc的前端(仿的jsdelivr的原本的界面用的bootstrap3，这个主要我不是很熟悉tailwind，用不明白)。

#### 然后呢，这个另外两个路径的话我就直接随便写写就得了。嗯，但是很显然啊，我这个测试的能力真的很有限，全部都是print或者with open写入。这个确实有点烦人的。后面做缓存和那个特殊版本号解析的时候，这个经常会要重构前面写好的代码(其实也就是修改一部分的内容)。

#### 我后来发现啊，到处print来判断自己写没写对这个真的有点麻烦。整体的项目做的很快，21号，开始做的，第二天晚上基本功能就做的差不多了，然后就好长时间没有动，国庆的这个周末开始做后续功能，做的还算是一般般。

#### 整个项目大部分地方都没有采取最佳的选项而是次要的技术栈选择，所以的话其实写的并不是很好，跑通倒是真的。

